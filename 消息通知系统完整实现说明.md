# 消息通知系统完整实现说明

## ✅ 已完成的功能

### 1. 后端实现

#### 数据库设计
- ✅ 创建 `message_notification` 表
- ✅ 支持基于用户ID和角色编码的消息过滤
- ✅ 支持消息分类：system/purchase/sale/inventory/user
- ✅ 支持消息类型：success/warning/info/error
- ✅ 支持跳转链接：purchase/sale/inventory/product/supplier
- ✅ 初始化测试数据（针对管理员、采购员、营业员）

#### 后端代码
- ✅ `MessageNotification` 实体类
- ✅ `MessageNotificationMapper` 接口
- ✅ `MessageNotificationVO` 视图对象
- ✅ `MessageNotificationService` 服务接口和实现
- ✅ `MessageNotificationController` 控制器

#### API接口
- `GET /messages/list?onlyUnread=false` - 获取消息列表
- `GET /messages/unread-count` - 获取未读消息数量
- `PUT /messages/{id}/read` - 标记消息为已读
- `PUT /messages/read-all` - 标记所有消息为已读
- `DELETE /messages/{id}` - 删除消息
- `DELETE /messages/clear-all` - 清空所有消息

---

### 2. 前端实现

#### API封装
- ✅ 创建 `src/api/message.js`
- ✅ 封装所有消息相关的API调用

#### 页面功能
- ✅ 修改 `Layout.vue`，实现动态消息获取
- ✅ 消息按钮显示未读数量（红色角标）
- ✅ 点击消息可跳转到对应管理页面
- ✅ 时间显示：刚刚/X分钟前/X小时前/昨天 HH:mm/MM-DD HH:mm
- ✅ 全部已读、清空消息功能
- ✅ 每30秒自动刷新未读消息数量

---

## 🎯 核心特性

### 1. 基于角色的消息过滤

**规则**：
- 消息的 `user_id` 和 `role_code` 可以为NULL（表示所有人可见）
- 查询条件：`(user_id = 当前用户ID OR user_id IS NULL) AND (role_code = 当前角色 OR role_code IS NULL)`

**示例**：
```sql
-- 管理员(user_id=1, role_code=ADMIN)登录时，可以看到：
-- 1. user_id=1 的消息（指定给管理员的）
-- 2. role_code=ADMIN 的消息（所有管理员可见）
-- 3. user_id=NULL 且 role_code=NULL 的消息（所有人可见）

-- 采购员(user_id=2, role_code=PURCHASER)登录时，可以看到：
-- 1. user_id=2 的消息（指定给该采购员的）
-- 2. role_code=PURCHASER 的消息（所有采购员可见）
-- 3. user_id=NULL 且 role_code=NULL 的消息（所有人可见）
```

---

### 2. 消息点击跳转功能

**跳转映射**：
| linkType | 跳转路由 | 说明 |
|----------|---------|------|
| purchase | /purchase | 采购管理页面 |
| sale | /sale | 销售管理页面 |
| inventory | /inventory | 库存管理页面 |
| product | /product | 商品管理页面 |
| supplier | /supplier | 供应商管理页面 |
| user | /user | 用户管理页面 |

**点击行为**：
1. 如果消息未读 → 标记为已读（调用API）
2. 如果有 `linkType` → 关闭抽屉并跳转到对应页面
3. 显示成功提示

---

### 3. 时间显示规则

| 时间差 | 显示格式 | 示例 |
|--------|---------|------|
| < 1分钟 | 刚刚 | 刚刚 |
| 1分钟 ~ 1小时 | X分钟前 | 30分钟前 |
| 1小时 ~ 24小时 | X小时前 | 2小时前 |
| 昨天 | 昨天 HH:mm | 昨天 14:30 |
| 更早 | MM-DD HH:mm | 11-05 09:15 |

---

## 🚀 部署和测试步骤

### 步骤1：创建数据库表

在DataGrip或命令行中执行：

```bash
# 在MySQL中执行
mysql -u root -p supermarket_db < sql/message_notification.sql
```

或者在DataGrip中：
1. 打开 `sql/message_notification.sql`
2. 选中所有内容
3. 点击 "Execute" 或按 Ctrl+Enter

**验证**：
```sql
USE supermarket_db;
SELECT * FROM message_notification;
-- 应该能看到12条测试消息
```

---

### 步骤2：重启后端

```bash
cd supermarket-backend

# 停止旧的进程（如果有）
# Ctrl+C

# 启动后端
mvn spring-boot:run
```

**启动成功标志**：
```
Started SupermarketApplication in X.XXX seconds
Tomcat started on port(s): 8080 (http) with context path '/api'
```

---

### 步骤3：启动前端

```bash
cd supermarket-frontend

# 安装依赖（如果是第一次运行）
npm install

# 启动开发服务器
npm run dev
```

**启动成功标志**：
```
VITE v5.4.0  ready in XXX ms
➜  Local:   http://localhost:3000/
```

---

### 步骤4：测试不同角色的消息

#### 测试管理员（admin）

1. 访问 http://localhost:3000
2. 登录：
   - 用户名：`admin`
   - 密码：`123456`
3. 点击右上角铃铛图标
4. **预期看到的消息**：
   - ✅ "采购审核提醒" - 采购订单待审核
   - ✅ "库存预警" - 可口可乐库存低
   - ✅ "系统通知" - 欢迎使用系统
   - ✅ "新用户注册" - 新用户待审核
   - ✅ "数据备份完成" - 系统备份成功
   - **共5条消息**（3条未读）

#### 测试采购员（purchaser）

1. 退出登录
2. 登录：
   - 用户名：`purchaser`
   - 密码：`123456`
3. 点击右上角铃铛图标
4. **预期看到的消息**：
   - ✅ "采购订单已通过" - 审核通过提醒
   - ✅ "采购入库完成" - 入库成功
   - ✅ "库存预警提醒" - 5件商品库存低
   - ✅ "系统通知" - 欢迎使用系统（所有人可见）
   - ✅ "采购订单超时" - 订单超时提醒
   - **共5条消息**（3条未读）

#### 测试营业员（cashier）

1. 退出登录
2. 登录：
   - 用户名：`cashier`
   - 密码：`123456`
3. 点击右上角铃铛图标
4. **预期看到的消息**：
   - ✅ "销售订单已完成" - 出库成功
   - ✅ "商品库存不足" - 雪碧库存不足
   - ✅ "销售统计更新" - 今日销售统计
   - ✅ "系统通知" - 欢迎使用系统（所有人可见）
   - **共4条消息**（2条未读）

---

## 🧪 功能测试清单

### 基础功能测试

- [ ] **未读数量显示**：铃铛图标右上角显示红色角标（数字正确）
- [ ] **消息列表显示**：点击铃铛，打开抽屉，消息列表正确显示
- [ ] **未读高亮**：未读消息有蓝色背景高亮
- [ ] **全部/未读切换**：两个Tab可以正常切换
- [ ] **时间显示**：时间格式正确（刚刚/X分钟前/昨天 HH:mm等）

### 交互功能测试

- [ ] **点击消息标记已读**：点击未读消息，蓝点消失，未读数量-1
- [ ] **消息跳转功能**：
  - [ ] 点击"采购审核提醒" → 跳转到采购管理页面
  - [ ] 点击"库存预警" → 跳转到库存管理页面
  - [ ] 点击"销售订单已完成" → 跳转到销售管理页面
- [ ] **全部已读**：点击"全部已读"按钮，所有消息标记为已读，未读数量变为0
- [ ] **清空消息**：点击"清空消息"，确认后消息列表为空

### 角色权限测试

- [ ] **管理员**：能看到所有类型的消息（5条）
- [ ] **采购员**：只能看到采购相关和系统消息（5条）
- [ ] **营业员**：只能看到销售相关和系统消息（4条）

### 实时性测试

- [ ] **自动刷新**：等待30秒，未读数量自动更新
- [ ] **跨页面刷新**：退出登录重新登录，未读消息正确显示
- [ ] **多次标记已读**：重复点击已读消息，不会报错

---

## 💡 如何添加新消息

### 方法1：直接插入数据库（适合测试）

```sql
USE supermarket_db;

INSERT INTO message_notification (
  user_id, role_code, type, category, title, content, link_type, link_id, is_read, create_time
) VALUES (
  1,                  -- 用户ID（NULL表示所有人）
  'ADMIN',           -- 角色编码（NULL表示所有角色）
  'warning',         -- 消息类型
  'purchase',        -- 消息分类
  '采购订单待审核',  -- 标题
  '采购订单 PO202411070010 待审核，请及时处理',  -- 内容
  'purchase',        -- 跳转类型
  10,                -- 关联业务ID
  0,                 -- 未读
  NOW()              -- 当前时间
);
```

### 方法2：在业务代码中创建（推荐）

在相关的Service中添加消息创建逻辑：

```java
@Service
public class PurchaseOrderServiceImpl {
    
    @Autowired
    private MessageNotificationService messageService;
    
    // 采购订单创建时，给管理员发送审核提醒
    public void createPurchaseOrder(PurchaseOrderDTO dto) {
        // ... 创建订单逻辑
        
        // 发送消息
        MessageNotification message = new MessageNotification();
        message.setRoleCode("ADMIN");
        message.setType("warning");
        message.setCategory("purchase");
        message.setTitle("采购审核提醒");
        message.setContent("采购订单 " + orderNo + " 待审核，请及时处理");
        message.setLinkType("purchase");
        message.setLinkId(orderId);
        message.setIsRead(false);
        message.setCreateTime(LocalDateTime.now());
        
        messageService.save(message);
    }
}
```

---

## 📋 未来扩展建议

### 1. WebSocket实时推送
- 当前实现是30秒轮询，未来可以改为WebSocket实时推送
- 新消息立即推送到前端，无需刷新

### 2. 消息已读状态优化
- 当前是每个用户共享同一条消息
- 可以改为：创建 `message_user_read` 表，记录每个用户的阅读状态

### 3. 消息模板
- 创建消息模板表，统一管理消息格式
- 支持占位符替换：`{orderNo}`、`{productName}` 等

### 4. 消息中心页面
- 创建独立的消息中心页面（`/messages`）
- 支持消息搜索、筛选、批量操作

### 5. 邮件/短信通知
- 重要消息可以通过邮件或短信同步发送
- 配置用户通知偏好

---

## 🔍 常见问题

### Q1：消息列表为空？
**A：** 
1. 检查数据库表是否创建成功：`SHOW TABLES LIKE 'message_notification';`
2. 检查测试数据是否插入成功：`SELECT COUNT(*) FROM message_notification;`
3. 检查后端日志是否有报错
4. 检查前端控制台（F12）是否有网络错误

### Q2：未读数量不更新？
**A：**
1. 检查后端接口是否正常：访问 `http://localhost:8080/api/messages/unread-count`
2. 检查前端是否正确调用API（查看Network面板）
3. 检查是否有跨域错误（CORS）

### Q3：点击消息无法跳转？
**A：**
1. 检查消息的 `linkType` 字段是否正确
2. 检查前端路由配置是否存在对应路径
3. 查看前端控制台是否有路由错误

### Q4：不同角色看到相同的消息？
**A：**
1. 检查后端Service的查询条件是否正确
2. 检查消息的 `role_code` 字段是否设置正确
3. 在后端添加调试日志，查看实际的查询SQL

---

## ✅ 完成标志

系统功能完整实现的标志：

- ✅ 数据库表创建成功，测试数据插入成功
- ✅ 后端接口可以正常访问（Swagger文档：http://localhost:8080/api/doc.html）
- ✅ 前端消息按钮显示未读数量
- ✅ 管理员、采购员、营业员登录看到不同的消息
- ✅ 点击消息可以跳转到对应页面
- ✅ 全部已读、清空消息功能正常

---

**现在您可以开始测试了！** 🎉

如果遇到任何问题，请查看：
1. 后端日志（控制台输出）
2. 前端控制台（F12 → Console）
3. 网络请求（F12 → Network）
4. 数据库数据（DataGrip或命令行）

